<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
  <title>Reading &amp; Writing Sensor Independent XML (2.1)</title>

  <section>
    <title>About</title>

    <para>The Sensor Independent XML library (<emphasis>six</emphasis>), is a
    cross-platform C++ API for reading and writing NGA's complex and derived
    sensor independent radar formats. Additionally it is the official
    reference implementation library for the Sensor Independent Derived Data
    (SIDD) format. The library is intended to be easy to use and integrate,
    without requiring extensive knowledge of XML or the underlying file
    formats. File format implementation concerns are handled separately from
    the data model, away from the end user. To create or read valid sensor
    independent formats using this library, the application developer is only
    concerned with populating the data model correctly. Reading and writing to
    NITF, GeoTIFF and XML are handled by the library internally. This also
    allows the library to be extended in the future to support new container
    formats or specification enhancements.</para>

    <para>To facilitate extension and keep the code and coding mistakes to a
    minimum, the library uses external open source libraries to handle file
    format interactions. To minimize errors in application development, the
    source incorporates some common C++ design patterns. However, to make the
    system easy to use for researchers, the main components of the data model
    are implemented purely as C-style structures.</para>

    <para>The <emphasis>six</emphasis> library is available as open-source
    software under the Lesser GNU Public License (LGPL). This license is
    commonly used in the open-source community, and allows applications that
    are not open source to make use of the library without penalty. As with
    other open source projects, the library is available as-is, with no
    warranty.</para>
  </section>

  <section>
    <title>Downloading the Library</title>

    <para>The <emphasis>six</emphasis> library is currently distributed via
    NGA's GitHub page, located at <ulink
    url="https://github.com/ngageoint/six-library">https://github.com/ngageoint/six-library</ulink>.
    The repository internally links to the MDA-IS
    <emphasis>CODA-OSS</emphasis> and <emphasis>NITRO</emphasis> projects on
    GitHub, using the <emphasis>git</emphasis> subtree merge strategy.
    Several <emphasis>CODA-OSS</emphasis> modules are used as a portable
    runtime, and <emphasis>NITRO</emphasis> is used to read and write NITF
    files. When a user does a clone from the git repository, the <emphasis>CODA-OSS</emphasis>
    and <emphasis>NITRO</emphasis> dependencies are already present as they have been merged
    into the <emphasis>six</emphasis> repository itself.</para>

    <para>Stable source code releases, with release notes, are provided intermittently on the <ulink url="https://github.com/ngageoint/six-library/releases">Releases</ulink> page.</para>

    <para>The latest source code can be obtained via the <ulink url="https://github.com/ngageoint/six-library/archive/master.zip">Download Zip</ulink> button on the main page.</para>

    <para>To clone the repository, a git client must be installed.  On Unix, the <emphasis>git</emphasis>
    command does the job.  Execute the following command:</para>

    <programlisting>$ git clone https://github.com/ngageoint/six-library.git</programlisting>
  </section>

  <section>
    <title>Building and Installing the Library</title>

    <para>The library requires a C++ compiler. Most modern C++ compilers
    should work. The library does make use of templates, exceptions, and
    namespaces, so old or non-standards compliant compilers should be used
    with caution. Refer to the table below for a listing of compilers and
    architectures that the <emphasis>six</emphasis> library is known to build
    on.</para>

     <table frame='all'><title>Architecture / Compiler Matrix</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
        <colspec colname='name'/> <colspec colname='help'/><thead>
        <row> <entry>Architecture</entry><entry>Compilers</entry></row></thead>
    <tbody>
    <row><entry>Windows XP 32-bit</entry><entry>Visual Studio 2008, 2010, 2012</entry></row>
    <row><entry>Windows XP 64-bit</entry><entry>Visual Studio 2008, 2010, 2012</entry></row>
    <row><entry>Linux 64-bit (x86_64)</entry><entry>GNU compiler collection 4.1-4.4</entry></row>
    <row><entry>Linux 34-bit</entry><entry>GNU compiler collection 4.1-4.4</entry></row>
    <row><entry>Solaris</entry><entry>SUN Studio 10, 11, 12, 12.3</entry></row>
    <row><entry>Mac 64-bit</entry><entry>GNU compiler collection 4.2.1</entry></row>
    </tbody>
    </tgroup>
    </table>

      <section>
      <title>Building with
      <emphasis>Waf</emphasis></title>

      <para>The <emphasis>six</emphasis> library uses the
      <emphasis>Waf</emphasis> build system to facilitate code compilation and
      installation. <emphasis>Waf</emphasis> is a cross-platform Python tool that
      enables developers to build the code in a standard way.
      The version of <emphasis>Waf</emphasis> bundled with the codebase is a
      custom modification of 1.7.14 and requires Python 2.7 or higher.
      The most recent release of Python 2.x is recommended
      (currently Python 2.7.10).</para>

      <para>In order to build on Windows, you will need a <emphasis>Visual
      Studio Compiler</emphasis> installed. <emphasis>Microsoft Visual Studio C++
      Express Edition</emphasis> is freely available, and is what the
      developers use to test <emphasis>six</emphasis> on Windows. To avoid
      potential issues, we suggest using the Visual Studio command prompt that
      comes bundled with the Visual Studio installation (it automatically
      sources the appropriate vcvars32.bat file for you), though building
      within a plain DOS shell (cmd.exe) without running this bat file
      normally works as well.</para>

      <para>To build, first get a complete checkout. Tools such as TortoiseGit
      make it easy to check out code from the repository on Windows. Once you
      have a sandbox, and can run Python on your Windows machine, you are
      ready to build from a DOS shell. The first step is to run <emphasis>waf
      configure</emphasis>. The <emphasis>Waf</emphasis> program is a Python
      script, and should either be run as an argument to Python, or you should
      make sure that the <emphasis>python</emphasis> executable is in your
      path. To verify you have a compliant version of Python installed, open
      a command prompt / shell window and type the following:
      </para>
      <programlisting>python --version</programlisting>

      <para>The following listing shows an example scenario of configuring,
      building, and installing the code. In this example we will be telling
      <emphasis>Waf</emphasis> to install locally to a directory named
      <emphasis>install</emphasis> and to use all the other default configure
      flags. Below the example you will find a table that lists other
      important configure-time flags you can use to customize your build.</para>

      <programlisting>
      &gt;cd C:\dev\six

      &gt;python waf configure --prefix=install
Setting top to                           : C:\dev\six
Setting out to                           : C:\dev\six\target
Platform                                 : win32
Checking for 'msvc' (c compiler)         : C:\Program Files (x86)\Microsoft Visu
al Studio 11.0\VC\BIN\x86_amd64\CL.exe
Checking for 'msvc' (c++ compiler)       : C:\Program Files (x86)\Microsoft Visu
al Studio 11.0\VC\BIN\x86_amd64\CL.exe
Checking for header inttypes.h           : not found
Checking for header unistd.h             : not found
Checking for header getopt.h             : not found
Checking for header malloc.h             : yes
Checking for header sys/time.h           : not found
Checking for header limits.h             : yes
Checking for header dlfcn.h              : not found
Checking for header fcntl.h              : yes
Checking for header check.h              : not found
Checking for header memory.h             : yes
Checking for header string.h             : yes
Checking for header strings.h            : not found
Checking for header stdbool.h            : not found
Checking for header stdlib.h             : yes
Checking for header stddef.h             : yes
Checking for function localtime_r        : not found
Checking for function gmtime_r           : not found
Checking for function mmap               : not found
Checking for function memmove            : yes
Checking for function memset             : yes
Checking for function strerror           : yes
Checking for function bcopy              : not found
Checking for type size_t                 : yes
Checking for type ssize_t                : not found
Checking for const keyword               : yes
Checking for unsigned short              : yes
Checking for unsigned char               : yes
Checking for library m                   : not found
Checking for library rt                  : not found
Checking for library sqrt                : not found
Checking for function erf                : not found
Checking for function erff               : not found
Checking for function setenv             : not found
Checking for function gettimeofday       : not found
Checking for function clock_gettime      : not found
Checking for function BSDgettimeofday    : not found
Checking for function gethrtime          : not found
Checking for function getpagesize        : not found
Checking for function getopt             : not found
Checking for function getopt_long        : not found
Checking for function isnan              : not found
Checking for type hrtime_t               : not found
Checking system type sizes               : yes
sizeof wchar_t                           : 2
sizeof long_long                         : 8
sizeof long                              : 4
bigendian                                : False
sizeof size_t                            : 8
sizeof double                            : 8
sizeof short                             : 2
sizeof int                               : 4
sizeof float                             : 4
Checking for 64-bit system               : yes
System size                              : 64-bit
Checking for program matlab              : C:\MATLAB\R2010a\bin\matlab.exe
Checking for header mex.h                : yes
Checking for library libmex              : yes
Checking for library libmx               : yes
Checking for program python              : C:\Python27\python.exe
Checking for python version              : 2.7.2
Checking for library python2.7 in $prefix/libs : not found
Checking for library python27 in $prefix/libs  : yes
Checking for program C:\Python27\python.exe-config,python2.7-config,python-confi
g-2.7,python2.7m-config : not found
Checking for header Python.h
                        : yes
Can build python bindings
                        : yes
Configuring with XML layer
                        : xerces
Checking for library advapi32
                        : yes
Checking for header netinet/in.h
                        : not found
Checking for header arpa/inet.h
                        : not found
Checking for header netdb.h
                        : not found
Checking for header intrin.h
                        : yes
Checking for header emmintrin.h
                        : yes
Checking for header wchar.h
                        : yes
Checking for header stdint.h
                        : yes
Checking for header stdio.h
                        : yes
Checking for header langinfo.h
                        : not found
Checking for header iconv.h
                        : not found
Checking for header nl_types.h
                        : not found
Checking for header ctype.h
                        : yes
Checking for header wctype.h
                        : yes
Checking for header cpuid.h
                        : not found
Checking for header endian.h
                        : not found
Checking for header machine/endian.h
                        : not found
Checking for header arpa/nameser_compat.h
                        : not found
Checking for header errno.h
                        : yes
Checking for header float.h
                        : yes
Checking for header locale.h
                        : yes
Checking for header sys/param.h
                        : not found
Checking for header sys/socket.h
                        : not found
Checking for header sys/stat.h
                        : yes
Checking for header sys/timeb.h
                        : yes
Checking for header sys/types.h
                        : yes
Checking for function mblen
                        : yes
Checking for function mbrlen
                        : not found
Checking for function mbsrtowcs
                        : not found
Checking for function mbstowcs
                        : yes
Checking for function wsctombs
                        : not found
Checking for function wcsrtombs
                        : not found
Checking for function realpath
                        : not found
Checking for function strchr
                        : yes
Checking for function strdup
                        : yes
Checking for function stricmp
                        : yes
Checking for function strnicmp
                        : yes
Checking for function strrcmp
                        : not found
Checking for function strstr
                        : yes
Checking for function strtol
                        : not found
Checking for function strtoul
                        : not found
Checking for function strcasecmp
                        : not found
Checking for function strncasecmp
                        : not found
Checking for function pathconf
                        : not found
Checking for function nl_langinfo
                        : not found
Checking for function iconv
                        : not found
Checking for function iconv_close
                        : not found
Checking for function iconv_open
                        : not found
Checking for function towupper
                        : yes
Checking for function towlower
                        : yes
Checking for function catclose
                        : not found
Checking for function catclose
                        : not found
Checking for function catgets
                        : not found
Checking for function catopen
                        : not found
Checking for function localeconv
                        : yes
Checking for function setlocale
                        : yes
Checking for function socket
                        : not found
Checking for function ftime
                        : yes
Checking for function getaddrinfo
                        : not found
Checking for library nsl
                        : not found
Building local lib
                        : xerces
Configuring with J2K layer
                        : openjpeg
Checking for function fseeko
                        : not found
Checking for header stdint.h
                        : yes
Checking for header sys/stat.h
                        : yes
Checking for header sys/types.h
                        : yes
Building local lib
                        : openjpeg
'configure' finished successfully (18.299s)
</programlisting>

      <note><para>It is important to note that the <emphasis>configure</emphasis> step
      should be run multiple times only if you need to modify the configuration variant. Most
      of the time you will end up running the configure phase just
      once, followed by one or more build/install phases</para></note>

      <table frame='all'><title>Notable <emphasis>configure</emphasis> options</title>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
            <colspec colname='name'/> <colspec colname='help'/><thead>
            <row> <entry>Option</entry><entry>Help</entry></row></thead>
        <tbody>
        <row><entry>--prefix</entry><entry>Installation prefix (configuration) [default: '/usr/local/']</entry></row>
        <row><entry>--with-optz=OPTZ</entry><entry>Specify the optimization level for optimized/release builds (med,fast,fastest) [default: 'fastest']</entry></row>
        <row><entry>--enable-debugging</entry><entry>Enable debugging</entry></row>
        <row><entry>--enable-64bit</entry><entry>Enables/forces 64bit builds [default: Will build 64-bit if compiler is available]</entry></row>
        <row><entry>--enable-32bit</entry><entry>Enables/forces 32bit builds</entry></row>
        <row><entry>--with-defs</entry><entry>Specify custom macro definitions</entry></row>
        <row><entry>--with-xml-home</entry><entry>Specify pre-built Xerces 3.1.1 location [default: Built automatically]</entry></row>
        </tbody></tgroup></table>

      <para>To see all available configure flags, use <emphasis>python waf --help</emphasis>.</para>

      <para>Once you have configured your build variant, the next step is to
      build the code. You do this by running <emphasis>waf build</emphasis> or
      just <emphasis>waf</emphasis> (they do the same thing).</para>

      <programlisting>&gt; python waf
...
...
'build' finished successfully (4m3.592s)

</programlisting>

      <para>The waf build process places build targets under their corresponding platform name in
      the <emphasis>target</emphasis> directory. If you are developing code
      in the codebase you can just use the binaries produced in this area rather than
      installing each time. As an application developer you will likely want to install
      the code to the <emphasis>prefix</emphasis> location you provided in the
      configure step. To install the targets (libs, headers and sample apps) just
      run <emphasis>waf install</emphasis>.</para>

      <programlisting>&gt; python waf install</programlisting>

      <note><para>If you always want to install the libraries, you can skip
      the <emphasis>waf build</emphasis> step and simply call
      <emphasis>waf install</emphasis>.</para></note>

      <para>Unix builds look more or less the same. Most of the time on Unix,
      it is not necessary to explicitly invoke <emphasis>python</emphasis> at
      the beginning of the command (although it is possible). Here are the
      commands run from a Linux box:</para>

      <programlisting>$ ./waf configure --prefix=install
...
'configure' finished successfully (3.438s)
Waf: Leaving directory `/home/user/six-user/trunk/target'
$ ./waf
...
'build' finished successfully (32.147s)
$ ./waf install
...
'install' finished successfully (1.650s)
</programlisting>

      <para>The <emphasis>Waf</emphasis> build system attempts to detect if it
      is running on a 64-bit architecture and defaults the compile flags
      accordingly. On some AMD chipsets, you may have to specify
      <emphasis>--enable-64bit</emphasis> explicitly or you may get a
      link-error between some of the compiled components. It is generally a
      good idea to always force certain options you want control over.</para>

      <para>When running <emphasis>waf build</emphasis> or
      <emphasis>waf install</emphasis> without a target list, it will build
      all targets it can find which include a number of test programs that
      may not be of interest to you.  You can specify individual targets to
      build at build/install time via the <emphasis>--target</emphasis> flag.
      This is a comma-separated list of all targets you'd like to build.
      <emphasis>Waf</emphasis> will automatically build any library dependencies
      that are needed.  After configuring, you can use
      <emphasis>python waf list</emphasis> to list all available targets.
      Here's an example of building just the SICD and SIDD libraries:</para>

      <programlisting>&gt; python waf install --target=six.sicd-c++,six.sidd-c++</programlisting>

      <para>After installing the library and its headers you will likely incorporate
      its use into your own applications.  We don't enforce the use of
      <emphasis>Waf</emphasis> for your own applications so you can use whatever ways you
      are already accustomed to.  However, it's critical that you use the same
      compiler defines that were used with <emphasis>Waf</emphasis> in order
      to not create a mismatch in your application.  After configuring, you
      can get the compiler flags that <emphasis>Waf</emphasis> would use for a
      given target or set of targets by running <emphasis>waf dumpenv</emphasis>
      and listing the targets you're interested in.  To do this for the SICD
      and SIDD libraries:</para>

      <programlisting>
      &gt; python waf dumpenv --target=six.sicd-c++,six.sidd-c++
      </programlisting>

      <note><para>Keep in mind that many compilers/linkers require libs
      to be listed in descending order, based on dependencies on one
      another, so link order <emphasis>does</emphasis> matter.  When building
      an application, you can always use the <emphasis>-v</emphasis> flag in
      order to see the exact compiler commands <emphasis>Waf</emphasis> is
      using.</para></note>

      <note><para>In earlier versions of SIX, this was more involved, but SIX
      now manages most of these for you by creating headers at configure time
      that pertain to the current system.  On all systems, you will want to
      set _LARGEFILE_SOURCE and _FILE_OFFSET_BITS=64 (which your build system
      may already be setting in order to support reading large files).  On
      Windows, you may need to also set _USE_MATH_DEFINES and NOMINMAX.  Also
      on Windows, you will need to set XERCES_STATIC_LIBRARY if you're using
      Xerces or XML_STATIC if you're using Expat and OPJ_STATIC for OpenJPEG
      (pertains to J2K compression in SIDD NITFs).</para></note>

      <para>After installation, there are two waf commands that allow for
      packaging the library for distribution. To create a Python wheel in
      the bin directory of your installation:</para>

      <programlisting>
      &gt; python waf makewheel

Creating wheel
Processing /home/user/six-user/six-library
Building wheels for collected packages: pysix
  Running setup.py bdist_wheel for pysix
  Stored in directory /home/user/six-user/six-library/install/bin
Successfully built pysix
      </programlisting>

      <para>A wheel is the standard format for distributing a Python module. It
      contains all information needed to simply install and run. Any missing
      depencies such as Numpy will automatically be installed as well. For
      more information, see PEP 427. To install a wheel:</para>

      <programlisting>
      &gt; pip install install/bin/*.whl
      </programlisting>

      <para>To convert the installation to a zip file:</para>

      <programlisting>
      &gt; python waf package
      </programlisting>
    </section>

    <section>
       <title>Sample Programs</title>

       <para>There are several sample programs that have been developed to
       demonstrate the <emphasis>six</emphasis> library in action. These samples
       should serve as a good starting point for a developer looking to incorporate
       the library into their own application.</para>

       <note><para>If you are not familiar with the SIO file format,
      you can still use your own raw image files as sources for several of these samples.
      Just modify the code to read the images using your own libraries and
      then pass the buffers to the writer <emphasis>save()</emphasis> method.</para></note>

      <section>
      <title>test_create_sidd_from_memory.cpp</title>
      <para>This sample generates a SIDD NITF file by using imagery from memory
      and combining it with a SICD XML file passed-in from the command line. You
      can extract the XML from a SICD by using
      <emphasis>test_extract_xml</emphasis>.</para>
      </section>
      <section>
      <title>test_dump_images.cpp</title>
      <para>This sample reads in a single SICD or SIDD file and dumps its images
      as separate files. The program gives command line options for the following:
      reading the entire image in-memory rather than one-line-at-a-time;
      chipping out a ROI; writing the file as an SIO.</para>
      </section>
      <section>
      <title>test_extract_xml.cpp</title>
      <para>This sample uses the NITRO library and extracts the XML
      contained in DES segments and writes them to separate files.</para>
      </section>
      <section>
      <title>test_parse_xml.cpp</title>
      <para>This sample parses the first XML DES from a SICD or SIDD NITF
      file (or a passed-in XML file) and generates a KML of the image footprint.</para>
      </section>
      <section>
      <title>test_round_trip.cpp</title>
      <para>This sample shows how to use the six library to read a SICD or SIDD
      file and then write it back to disk.</para>
      </section>
      <section>
      <title>test_create_sicd.cpp</title>
      <para>This sample shows how you can take an existing image file (in this case, an SIO)
      and combine it with the SICD model data (in this case, fabricated) to
      generate a SICD NITF product. Command line options allow you to override
      the segmentation limitations to force image segmentation within the NITF.
      </para>
      </section>
      <section>
      <title>test_create_sidd.cpp</title>
      <para>This sample shows how you can take an existing derived image file
      (in this case, an SIO) along with a SICD XML file to generate a SIDD
      NITF product. The SIDD model data is fabricated.</para>
      </section>
    </section>

    <section>
      <title>Library Dependencies</title>

      <para>The XML handler library used by the library (called
      <emphasis>xml.lite</emphasis>) is a lightweight implementation of a
      simple Document Object Model (DOM) using one of several freely available
      popular open source XML libraries as a driver. At build configuration
      time, the developer can tell <emphasis>xml.lite</emphasis> to use
      <emphasis>expat</emphasis>, <emphasis>Apache Xerces-C++</emphasis>, or
      another library (check at configure time to see the latest
      options).</para>

      <para>By default, <emphasis>six</emphasis> will use the
      <emphasis>Xerces</emphasis> library to do XML parsing.  This is the
      recommended library to use as <emphasis>Expat</emphasis> does not support
      schema validation.  If the build system finds <emphasis>Xerces</emphasis>
      on the target system and the <emphasis>--nobuild-xml</emphasis> configure
      flag is used, it will attempt to use the installed version. If it does
      not, it will attempt to build it from scratch from an internally bundled
      driver the first time the library is built. If <emphasis>Xerces</emphasis>
      already is installed on your system, you can use the
      <emphasis>--with-xml-home</emphasis> option to set the proper include and
      lib paths for the build system. To switch the xml library to the
      <emphasis>Expat</emphasis> parser, use the
      <emphasis>--enable-xml-layer=expat</emphasis> flag, optionally in
      conjunction with the <emphasis>--with-xml-home</emphasis> path,
      identifying the location of <emphasis>Expat</emphasis>, if it is not in
      the sytem path.</para>

      <para>The <emphasis>NITRO</emphasis> library is MDA-IS software that
      aims to be a complete implementation of the NITF MIL-STD2500C. It is
      cross-platform, widely-used, and under active development and
      maintenance. The <emphasis>NITRO</emphasis> C library is bundled
      internally and automatically built on first use.</para>

      <para>The SIDD file format optionally does support GeoTIFF. It currently
      uses the <emphasis>tiff</emphasis> module in CODA-OSS, which is a
      minimalist implementation of the format. </para>

      <note>
        <para>It is likely that the library will support the standard
        <emphasis>libtiff</emphasis> library as a driver in the future.
        </para>
      </note>
    </section>
  </section>

  <section>
    <title>Library Design Idioms, Rules and Conventions</title>

    <para>While every attempt was made to keep the library minimalist,
    supporting both SICD and SIDD in one library requires a fair amount of
    code. To make it easy to maintain and use the library, certain idiomatic
    coding conventions are used. This section attempts to document these
    conventions and their rationale.</para>

    <section>
      <title>Naming and Type Conventions</title>

      <para>Classes and structures follow Java style naming conventions. The
      first letter is always upper case, and the class methods and fields
      always begin with a lower case letter. Camel-casing is always used.
      Fields in a class are primarily protected or private, and are prefixed
      by an <emphasis>'m'</emphasis>, denoting that they are member fields.
      Structure fields are always public scope and the fields are not prefixed
      as they are in classes. Most types in the library have overloaded
      methods to allow them to be printed as a string, or read in from
      strings, using the <emphasis>str::toString()</emphasis> and
      <emphasis>str::toType()</emphasis> methods . Basic primitives and
      enumerations are used where possible to minimize the code base and to
      provide a consistent API. Where these already exist in the
      <emphasis>CODA-OSS</emphasis> runtime, they are reused. Types that are
      taken from other <emphasis>CODA-OSS</emphasis> modules are often
      <emphasis>typedef</emphasis>'ed within <emphasis>six</emphasis>, to
      allow us to change their implementations in the future as
      necessary.</para>
    </section>

    <section>
      <title>Data Model Conventions</title>

      <para>The library tries to implement the idea of Separation of Concerns
      (SoC) -- the concept that an object should focus on only one thing and
      do it well. This minimizes bugs and creates loose-coupling and strong
      cohesion. With respect to the blocks described by SICD and SIDD, we keep
      the object representation separate from the actions that transform it.
      The former is called the "data model" and the latter are called "actors"
      or "controls." To make things as simple as possible, C-style structures
      are used to represent all of the components in the data model for SICD
      and SIDD formats. This, theoretically, allows the actors to be extended
      for other packaging mechanisms, but it also just makes it easier for an
      application developer to write code.</para>

      <para>Most modern XML code-generation binding frameworks generate data
      models that are tightly coupled with their XML representations. Here we
      have made an explicit effort to separate the model from how it is
      serialized. Certainly the XML reader and writer need to know what a
      <emphasis>ComplexData</emphasis> object looks like, but in most cases,
      that should be hidden from the application itself, and from the data
      model itself.</para>

      <para>Additionally, most XML binding frameworks create objects that are
      based on the names of the XMLSchema-defined types. This can be helpful
      when dealing with schemas that have duplicate element names, and lots of
      dependencies. The <emphasis>six </emphasis>library tries to keep the
      data model closer to something that looks more like the XML instance, so
      that the application developer does not have to thumb through the schema
      every time looking for the type names.</para>

      <para>For example, one type in the SIDD schema is identified as
      <emphasis>exploitationfeaturescollectionphenomenologytype</emphasis>,
      but its single existing usage within SIDD is as a
      <emphasis>Phenomenology</emphasis> element in the XML instance. A
      typical binding library would generate an
      <emphasis>exploitationfeaturescollectionphenomenologytype</emphasis>
      structure, and the parent would have a pointer to a
      <emphasis>phenomenology</emphasis> property, but that would mean that
      any function that acts on the type would need to reference the type
      name, not the instance name. We felt that it was less confusing for the
      application to pass a <emphasis>Phenomenology </emphasis>structure
      instead, and keep the property in the parent as
      <emphasis>phenomenology</emphasis> as well, mirroring the name as it
      appears in the actual XML data.</para>

      <note>
        <para>There are places in the data model where the property or class
        name deviates slightly from the name as it appears in the XML
        instance. These differences usually arise from the desire to keep a
        consistent API. Each occurence is documented individually in the
        <emphasis>doxygen</emphasis> comments along with the actual SICD or
        SIDD element name.</para>
      </note>
    </section>

    <section>
      <title>Resource Initialization, Cloning and Destruction</title>

      <para>The data model root object is called <emphasis>Data</emphasis>,
      and its sub-class implementations for SICD
      (<emphasis>ComplexData</emphasis>) and SIDD
      (<emphasis>DerivedData</emphasis>). The <emphasis>Data</emphasis> class
      provides a minimal contract to its sub-classes, including some utility
      methods to get information that is required for both derived classes,
      but may live in different places in each objects XML representation.
      Each derived <emphasis>Data</emphasis> class has pointers to its XML
      blocks (top level elements). Every object underneath a derived
      <emphasis>Data</emphasis> implementation is part of the data
      model.</para>

      <para>Data model objects are initialized as soon as possible. This
      usually means that if there are choices contained in the building of a
      complex object, an enumeration will be passed to the constructor to tell
      the object how to initialize. An object in the data model with a
      required sub-field is required to allocate the sub-structure as soon as
      it is created. Allocations for single objects are done using
      <emphasis>new</emphasis>. C++ STL vectors are used to store unbounded
      objects. Any objects contained in a vector that are pointers are also
      allocated with the <emphasis>new</emphasis> keyword. If a required
      sub-field has one or more elements, the library will initialize one
      element in the sub-vector.</para>

      <para>Objects with optional types are not initialized in the
      constructor. They are either set to a special undefined state or set to
      NULL if they are pointers. Pointers are used for objects that have many
      configuration details, or where an undefined state cannot be determined
      without using NULL. A NULL-comparison is the only way to determine if a
      pointer object is initialized in the library. Therefore, all
      constructors must NULL-initialize any non-required pointers. An object
      in the data model owns its sub-fields. It is expected to
      <emphasis>delete</emphasis> them. If an application developer wishes to
      own a copy of some object within a data model, it must create it from
      scratch, or <emphasis>clone()</emphasis> it from an object in the model.
      Optional and unbounded sub-fields are represented by an empty STL
      vector. It is up to the application to provide optional elements by
      inserting the into the vector as needed.</para>

      <para>Optional elements in the model should be allocated by the
      application using the <emphasis>new</emphasis> keyword. Once its pointer
      is assigned in the sub-field of a data model object, that object owns it
      and will be responsible for deleting it. The caller should not
      <emphasis>delete</emphasis> this optional element, unless it first sets
      the parent's pointer field for that element back to NULL. The provided
      <emphasis>ComplexDataBuilder</emphasis> and
      <emphasis>DerivedDataBuilder</emphasis> objects will allow the
      application to create any optional top-level blocks in a
      <emphasis>Data</emphasis> object.</para>

      <para>All objects in the data model must provide a
      <emphasis>clone()</emphasis> method. The <emphasis>clone()</emphasis>
      method contract requires that the object make a deep copy of itself
      (this is sometimes called a 'Prototype' design pattern). Prior to
      cloning, any sub-field pointers are compared against NULL first. If a
      sub-field object is NULL, the cloned object will also contain a NULL
      sub-field.</para>

      <para>Since an object in the data model owns its own children,
      destructors are required to test each pointer type against NULL, prior
      to deletion. Non-NULL objects are freed using the
      <emphasis>delete</emphasis> keyword.</para>
    </section>

    <section>
      <title>Actor Conventions and Patterns</title>

      <para>Actors (also referred to in the library as controls) are object
      that perform an action on a data model. They are not part of the model
      and are implemented as C++ classes. Most often, the developer encounters
      these objects when reading or writing a file. Actors often define a
      contractual interface, and sub-classes provide the implementation
      wherever possible. The interface/implementation convention is more
      flexible, and makes it easier to extend the library as necessary. For
      example, the <emphasis>ReadControl</emphasis> interface defines the
      contract for all SICD/SIDD read capabilities. To read a NITF, a
      <emphasis>NITFReadControl</emphasis> sub-class would be created. To read
      a GeoTIFF, the <emphasis>GeoTIFFReadControl</emphasis> sub-class is
      used. The same is true for <emphasis>WriteControl</emphasis>'s contract.
      Actors can be new-allocated with a factory method, or created on the
      stack if the implementation is known upfront. The example below shows
      good encapsulation of <emphasis>WriteControl</emphasis> creation, where
      the instantiation is separate from usage:</para>

      <programlisting>// Trivial example of factory-type set-up for a WriteControl
void createWriter(std::string siddFile)
{
    six::WriteControl* writer = NULL;

    // This example uses NITRO, but we could just check the extension
    if ( nitf::Reader::getNITFVersion(siddFile) == NITF_VER_UNKNOWN )
    {
        writer = new six::NITFWriteControl();
    }
    else
    {
        // Assume for this example it would be this otherwise
        writer = new six::GeoTIFFWriteControl();
    }
    return writer;
}
</programlisting>

      <para>The <emphasis>XMLControl</emphasis> interface provides a contract
      for serialization of a data model to and from a DOM, -- a standard
      structure for XML manipulation. <emphasis>XMLControl</emphasis> may be
      used independently from the <emphasis>ReadControl</emphasis> and
      <emphasis>WriteControl</emphasis>, since its job is not to write a file,
      but to change representations. Derived implementations exist for
      <emphasis>DerivedData</emphasis> and <emphasis>ComplexData</emphasis>,
      called <emphasis>DerivedXMLControl</emphasis> and
      <emphasis>ComplexXMLControl</emphasis>, respectively. These can be
      instantiated directly, or using the
      <emphasis>XMLControlFactory</emphasis> if the <emphasis>Data</emphasis>
      sub-class is not known by the caller.</para>

      <programlisting>// ComplexData* data

// Generically, from a Data*
six::XMLControl *genericControl =
    six::XMLControlFactory::newXMLControl(data-&gt;getDataClass());

// Concretely if we know what Data type we have
xml::lite::Document* dom = six::ComplexXMLControl().toXML(data);

// Or backwards
ComplexData* complexData = (ComplexData*) genericControl-&gt;fromXML(dom);

// Dump DOM to standard out
io::StandardOutStream stream;
dom-&gt;getRootElement()-&gt;prettyPrint(stream);

// Be a good citizen
delete dom;
delete genericControl;
</programlisting>

      <para>Since the library takes care of XML automatically, the application
      may never need to use an <emphasis>XMLControl</emphasis> directly, but
      it is available if necessary. Utilities exist to convert the data model
      directly into a byte array or std::string as well, without needing using
      an <emphasis>XMLControl</emphasis> directly:</para>

      <programlisting>char* charArray = six::toXMLCharArray(data);
std::string str = six::toXMLString(data);
...
// Be a good citizen
delete [] charArray;
</programlisting>

      <para>The <emphasis>DerivedData</emphasis> object can be rigorously
      created using pointer assignments in the model. Alternately, there is an
      implementation of the 'Builder' design pattern built into the library
      which can help. The builders for 2.0 do not allow the user to build
      every single component in the data model. For details, consult the
      <emphasis>doxygen</emphasis>:</para>

      <programlisting>six::ComplexDataBuilder cdb;

// Operators can be chained.  Each function updates the model
cdb.addImageCreation().addImageData(six::RE32F_IM32F);

// Get ownership over the builder's data
six::ComplexData* sicdData = cdb.steal();

// Add the complex data object to a SICD Container so we can write later
six::Container* container = new six::Container(six::TYPE_COMPLEX);
container-&gt;addData( sicdData );

</programlisting>
    </section>
  </section>

  <section>
    <title>TRE plugin path</title>
    <para>Beginning with SICD/SIDD 1.0, the spec requires a user-defined subheader
    (XML_DATA_CONTENT) to be present in the NITF's DES.  <emphasis>six</emphasis>
    populates this subheader automatically but it is implemented at the NITRO
    layer via a plugin (which <emphasis>Waf</emphasis> builds automatically)
    that you need to point <emphasis>six</emphasis> to.  One way to do this is
    via the environment variable NITF_PLUGIN_PATH.  From the same directory
    you built <emphasis>six</emphasis> in, on Windows:</para>
    <programlisting>
    &gt;set NITF_PLUGIN_PATH=%cd%\install\share\nitf\plugins
    </programlisting>
    <para>On Unix (exact syntax may depend on your shell):</para>
    <programlisting>
    $ setenv NITF_PLUGIN_PATH `pwd`/install/share/nitf/plugins
    </programlisting>
    <para>Alternatively, you can do this in your program by calling six::loadPluginDir().
    Having this plugin path set is required when writing 1.0+ products (you
    will get an error if the path is not set).  It is not currently required
    for reading but this may change in the future.
    </para>
  </section>

  <section>
    <title>XML schema path</title>
    <para>
    <emphasis>six</emphasis> automatically performs schema validation when
    reading and writing SICD/SIDD products.  To do this, it needs the
    corresponding schema files for each version.  These are provided with
    <emphasis>six</emphasis> and automatically installed by
    <emphasis>Waf</emphasis>.  One way to point <emphasis>six</emphasis> to
    these is via the environment variable SIX_SCHEMA_PATH.  From the same
    directory you built <emphasis>six</emphasis> in, on Windows:</para>
    <programlisting>
    &gt;set SIX_SCHEMA_PATH=%cd%\install\conf\schema\six
    </programlisting>
    <para>On Unix (exact syntax may depend on your shell):</para>
    <programlisting>
    $ setenv SIX_SCHEMA_PATH `pwd`/install/conf/schema/six
    </programlisting>
    <para>Alternatively, you can do this in your program by providing this
    directory in the <emphasis>schemaPaths</emphasis> vector when calling
    ReadControl::load() or WriteControl::save().  Providing this path via
    one of these two mechanisms is required for both reading and writing (you
    will get a validation error if the path is not set).
    </para>
  </section>

  <section>
    <title>Using <emphasis>six</emphasis> to Read/Write Sensor Independent
    Derived Data (SIDD)</title>

    <para>SIDD currently supports two file formats, NITF 2.1 and GeoTIFF,
    typically referred to as "containers" in document jargon. The C++
    <emphasis>Container</emphasis> object models the file format container,
    encapsulating one or more Data items in the order that they will be
    written (or that they were read). A SIDD file stored in either of these
    formats contains an XML meta-data section described by the SIDD XML
    Schema. It is possible to use the <emphasis>six</emphasis> library to read
    and write meta-data and imagery from either type of file, as well as to
    load or store its meta-data to or from a raw XML document.</para>

    <section>
      <title>Reading</title>

      <para>Reading is multi-pass. The library reads meta-data using
      the<emphasis> load()</emphasis> function. To read image data, the
      <emphasis>interleaved()</emphasis> function should be used. The name
      alludes to the fact that multi-band data is read into a buffer in band
      interleaved order, as opposed to providing the developer with a separate
      buffer for each band. The latter method may be supported in the future
      using another API call.</para>

      <para>The SICD file format only allows one SICD XML and image per file
      format container (see the SICD File Format Design Document for details).
      The SIDD format allows multiple SICD and SIDD XML data and multiple
      derived images within a container (see the SIDD File Format Design
      Document for details). The <emphasis>ReadControl</emphasis>'s contract
      is modeled in a way that it does not care whether the data is SICD or
      SIDD. Currently, since SICD has only one defined official container
      format, NITF, the <emphasis>NITFReadControl</emphasis> is the only
      derived reader that can be used for SICD data. The
      <emphasis>NITFReadControl</emphasis> and
      <emphasis>GeoTIFFReadControl</emphasis> may be used to read SIDD data.
      The interface does not change, irrespective of container format or
      sensor data format. Here is an example of reading SICD meta-data from a
      read control:</para>

      <programlisting>// Create the reader
six::NITFReadControl reader;

// Load the image, bind it to a container
reader.load("/path/to/sicd.nitf");

// Get the container
mem::SharedPtr&lt;six::Container&gt; c = reader.getContainer();

// Get the SICD data model
six::ComplexData* sicd = (six::ComplexData*)c-&gt;getData(0);

// Read the number of rows using Data* base virtual method
std::cout &lt;&lt; sicd-&gt;getNumRows() &lt;&lt; std::endl;

//--------------------------------------------------------------
// Read the number of rows using ComplexData* structure
// Note this corresponds roughly to the XPath statement:
// /SICD/ImageData/NumRows
//--------------------------------------------------------------
std::cout &lt;&lt; sicd-&gt;imageData-&gt;numRows &lt;&lt; std::endl;

</programlisting>

      <para>The same method can be used to read in SIDD
      <emphasis>DerivedData</emphasis>. The SIDD specification allows the file
      format container to include SICD XML about the collection, and one or
      more SIDD sections as well. It is up to a "profile" to determine how
      this data is ordered. For the purposes of our example, we will say that
      the profile for this particular data specifies that there will be one
      SIDD XML followed by its parent products' SICD XML. Since this is a
      SIDD, it could be a NITF or a GeoTIFF, but lets imagine that the profile
      only allows a NITF for this particular type of product:</para>

      <programlisting>//--------------------------------------------------------------
// This code does not rigorously check that the product
// actually matches its profile, it assumes that it is valid
//--------------------------------------------------------------

// Create the reader
six::NITFReadControl reader;

// Load the image, bind it to a container
reader.load("/path/to/sidd.nitf");

// Get the container
mem::SharedPtr&lt;six::Container&gt; c = reader.getContainer();

// Get the SIDD data model (first data block)
six::DerivedData* sidd = (six::DerivedData*)c-&gt;getData(0);

// Read the number of rows using Data* base virtual method
std::cout &lt;&lt; sidd-&gt;getNumRows() &lt;&lt; std::endl;

//--------------------------------------------------------------
// Read the number of rows using DerivedData* structure
// Note this corresponds roughly to XPath statement:
// /SIDD/Measurement/PixelFootprint/Row
//--------------------------------------------------------------
std::cout &lt;&lt; sicd-&gt;measurement-&gt;pixelFootprint.row &lt;&lt; std::endl;

// Get the SICD data model (second data block)
six::ComplexData* sicd = (six::ComplexData*)c-&gt;getData(1);
...

</programlisting>

      <para>Due to the details of the container formats, some differences
      exist among derived <emphasis>ReadControl</emphasis>s. In the case of
      NITF, a single image segment size is limited to at most, around 10GB of
      data. The TIFF file format itself is limited to 4GB in its entirety. To
      circumvent the NITF issue, both SICD and SIDD file format documentations
      define an algorithm for properly segmenting one continuous image into
      multiple segments within the NITF. Since neither format uses TREs, this
      is relatively straightforward as far as meta-data is concerned, but it
      does require some book-keeping, and some updates to the NITF CCS. A goal
      of the <emphasis>six</emphasis> library is to hide the details of the
      file format container as much as possible. To that end, the library
      hides segmentation rules from the application developer, and instead,
      presents the developer with access to one virtual SICD image,
      irrespective of how many segments exist in the NITF. With SIDD images,
      each image may end up segmented (this is very unlikely to occur in
      real-life scenarios), and each product is presented as a virtual SIDD
      image, similar to the SICD usage. Therefore, the application developer
      will have no need to access the NITF image segment data, since the XML
      contains the meta-data for the full pixel array.</para>

      <para>SICD pixel arrays contain a band for real and a band for imaginary
      data. The data is represented with each pixel made up of one real
      component and one imaginary. In NITF jargon, this is called
      'band-interleaved by pixel.' SIDD 24-bit RGB pixel arrays are
      interleaved the same way, where each pixel is organized one after
      another as a byte of red, a byte of green, and a byte of blue, followed
      by the next pixel. SIDD monochrome data and RGB 8-bit LUT data is
      presented as a single band. In the latter case, the 8-bit value is an
      index into the value:</para>

      <programlisting>// Print a LUT for a given indexPixel
six::LUT* lut = sidd-&gt;display-&gt;remapInformation-&gt;remapLUT;
char* pixel = (*lut)[indexPixel];
short r = (short)pixel[0];
short g = (short)pixel[1];
short b = (short)pixel[2];
std::cout &lt;&lt; "R,G,B: " &lt;&lt; r &lt;&lt; ',' &lt;&lt; g &lt;&lt; ','&lt;&lt; b &lt;&lt; std"::endl;

</programlisting>

      <para>Reading interleaved data using a <emphasis>ReadControl</emphasis>
      is done using a <emphasis>Region</emphasis> object, which specifies the
      window to be read. The caller can allocate a buffer for reading, and
      reuse it at a later point. Otherwise, the library will create a buffer
      of the appropriate size, and give it back to the user. If the caller
      allocates its own memory, it should be careful to ensure that it has
      allocated the right amount prior to calling the<emphasis>
      interleaved()</emphasis> function, in order to avoid memory corruption.
      The requested window size is established in the
      <emphasis>Region</emphasis>. If the <emphasis>numRows</emphasis> and
      <emphasis>numCols</emphasis> are not set, or are set to -1, the
      <emphasis>ReadControl</emphasis> will read from the start points up to
      the end of the image into the buffer, and then sets the actual
      <emphasis>numRows</emphasis> and <emphasis>numCols</emphasis> in the
      region prior to returning:</para>

      <programlisting>// Read one row at a time from a SICD container, and write to a file
Region region;
region.setNumRows(1);

// Get the first data object
Data* sicdData = container-&gt;getData(0);

// Allocate a one line buffer to read complex data
unsigned long nbpp = sicdData-&gt;getNumBytesPerPixel();
unsigned long height = sicdData-&gt;getNumRows();
unsigned long width = sicdData-&gt;getNumCols();
unsigned long nbpr = nbpp * width;
workBuffer = new UByte[nbpr];

// Set it in the region
region.setBuffer(workBuffer);

// Set up an output file
io::FileOutputStream outputStream(outputFile);

// For each line in the image
for (unsigned int i = 0; i &lt; height; i++)
{
    // Update the start row, other than that
    // no need to modify region, we are okay
    region.setStartRow(i);
    UByte* line = reader-&gt;interleaved(region, 0);
    outputStream.write((const sys::byte*) line, nbpr);
}
// Must delete our work buffer
delete [] workBuffer;
// Delete or ReadControl
delete reader;
// Close our output stream
outputStream.close();</programlisting>

      <para>It might be convenient in some cases to allow the library to
      allocate enough memory for the request:</para>

      <programlisting>// Read a chip out of the image
region.setStartRow(startRow);
region.setEndRow(endRow);
region.setStartCol(startCol);
region.setEndCol(endCol);

std::complex&lt;float&gt;* chip =
    (std::complex&lt;float&gt;*)reader-&gt;interleaved(region, 0);

...

// Still have to do this at the end
delete [] region.getBuffer();

</programlisting>
    </section>

    <section>
      <title>Writing</title>

      <para>To write, the application developer will use the
      <emphasis>WriteControl</emphasis> contract, using the appropriate
      sub-class. It is important that the contents of the
      <emphasis>Container</emphasis> be filled and organized in the order that
      it is to be written in the file. There should be only one
      <emphasis>Data</emphasis> inside a SICD <emphasis>Container</emphasis>,
      and there will be only one image source passed into the
      <emphasis>save()</emphasis> function. For SIDD Container's, all
      meta-data will be written out, but the number of SIDD Data objects will
      correspond one-to-one with the number of image sources provided to the
      save() call. There are two types of image sources that the
      <emphasis>WriteControl</emphasis> accepts. The first is a byte buffer.
      This makes it easy to write an in-memory pixel array out to a SICD or
      SIDD. The second method is via the <emphasis>io::InputStream</emphasis>
      interface. In short, any class that derives
      <emphasis>InputStream</emphasis> can be used as an image source for
      writing, including <emphasis>io::FileInputStream</emphasis>,
      <emphasis>io::StringStream</emphasis>, and any source that an application
      developer can adapt to a stream. Creating a new <emphasis>InputStream
      </emphasis>sub-class is trivial, since only two functions must be
      overriden (one telling how many bytes are in the stream, and one to read
      a specified number of bytes from the stream. The example below shows how
      to write an unidentified stream into a SIDD image pixel array:</para>

      <programlisting>//--------------------------------------------------------------
// Assume the Container is properly set up
// and that we have two images in this SIDD product
// That means the container has two SIDD instance already
// Set up (perhaps some ComplexData as well
//--------------------------------------------------------------

// See create example above for pseudo-impl
WriteControl* writer = createWriter(file);

// Set up the container.
writer.initialize(container);

// We have a source for each image
std::vector&lt;io::InputStream*&gt; sources;

//--------------------------------------------------------------
// Some function to create a derived impl of InputStream
// Lets say this source function needs to know pixel array
// information contained in the DerivedData section
//--------------------------------------------------------------
io::InputStream* is1 =
    createInputSourceForProduct1(params, container-&gt;getData(0));

// Same type of function, but needs MD for SIDD data 1, not 0
io::InputStream* is2 =
    createInputSourceForProduct1(params, container-&gt;getData(1));

sources.push_back( is1 );
sources.push_back( is2 );

// Save the file
writer-&gt;save(sources, outputName);

// Delete the sources
for (unsigned int i = 0; i &lt; sources.size(); ++i)
    delete sources[i];

</programlisting>
    </section>
  </section>

  <section>
    <title>Getting Help and Reporting Bugs</title>

    <para>This library is provided as-is. This document is meant to help
    developers, but when in doubt, the online Doxygen generated API
    documentation or, if necessary, source code should be consulted. If you
    fix a bug or make enhancements to this freely provided source code, the
    LGPL requires that you submit your changes back to the copyright
    holders.</para>

    <para>Software defects should be reported using the GitHub Issues page
    (currently <ulink
    url="https://github.com/ngageoint/six-library/issues">https://github.com/ngageoint/six-library/issues</ulink>)
    available at the current project hosting location. To post an issue, you
    must login to GitHub first. When reporting a bug, try to be as specific as possible when
    describing the problem. Please also provide sample code. If the code in
    question is on a different network, or non-disclosable, please attempt to
    make a short, concise example that would replicate the problem you are
    seeing. We do not currently have an email group for help or discussion.</para>
  </section>

  <?hard-pagebreak?>
  <appendix><title>Build Alternatives</title>

    <section>
      <title>Building on Windows within Visual Studio</title>

      <para><emphasis>Waf</emphasis> supports the ability to generate a Visual
      Studio 2010 solution file.  After configuring, this can be done via</para>
      <programlisting>
      &gt;python waf msvs
      </programlisting>
      <para>SIX support for this is still in a beta state - the main shortcoming of
      the currently-generated solution file is that it contains projects for
      each library and test program, including a large number of NITRO TRE
      plugins that are not used by SIX.  However, the six.sicd and six.sidd
      projects inside this solution may still be useful.</para>
    </section>

  </appendix>
</article>
